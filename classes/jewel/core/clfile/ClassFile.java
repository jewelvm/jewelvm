/* JEWEL, Java Environment With Enhanced Linkage
 * Copyright (c) 1998-2004, Rodrigo Augusto Barbato Ferreira
 */
package jewel.core.clfile;

import jewel.core.clfile.ClassInfo.ConstantPool;
import jewel.core.clfile.ClassInfo.FieldInfo;
import jewel.core.clfile.ClassInfo.MethodInfo;
import jewel.core.clfile.ClassInfo.MethodInfo.CodeInfo;
import jewel.core.clfile.ClassInfo.MethodInfo.CodeInfo.HandlerInfo;
import jewel.core.clfile.ClassInfo.InnerInfo;

import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.EOFException;
import java.io.IOException;
import java.io.UTFDataFormatException;
import java.util.Arrays;
import java.util.Comparator;

/**
 * The <CODE>ClassFile</CODE> class provides read only access
 * to the contents of a <CODE>class</CODE> file format. The
 * <CODE>class</CODE> file format is the binary executable
 * file in the Java architecture. It is generated by Java
 * source compilers, e.g.<CODE>javac</CODE>, and read by the
 * JVM during execution.<P>
 * This class is a straight line implementation based on the
 * <CODE>class</CODE> file format description found in the
 * chapter four of "The Java Virtual Machine Specification,
 * Second Edition".
 */
public final class ClassFile implements ClassFileConstants, ClassInfo {

  /**
   * Creates a <CODE>ClassFile</CODE> object deriving it from
   * its binary class image, provided as an array of bytes.
   *
   * @param buffer the byte array containing the class image.
   * @return a <CODE>ClassFile</CODE> object.
   * @exception UnsupportedClassVersionException if the class
   *            version is not supported by this implementation.
   */
  public static ClassFile parseImage(byte[] buffer) throws ClassFormatException {
    return parseImage(buffer, 0, buffer.length);
  }

  /**
   * Creates a <CODE>ClassFile</CODE> object deriving it from
   * its binary class image, provided as an array of bytes region.
   *
   * @param buffer the byte array containing the class image.
   * @param start the offset where the image starts.
   * @param length the length of the class image.
   * @return a <CODE>ClassFile</CODE> object.
   * @exception UnsupportedClassVersionException if the class
   *            version is not supported by this implementation.
   */
  public static ClassFile parseImage(byte[] buffer, int start, int length) throws ClassFormatException {
    DataInputStream in = new DataInputStream(new ByteArrayInputStream(buffer, start, length));
    ClassFile classFile = null;
    try {
      try {
        classFile = new ClassFile(in);
      } catch (EOFException e) {
        throw new ClassFormatException("Truncated class file");
      }
      try {
        in.readByte();
        throw new ClassFormatException("Extra bytes at the end of the class file");
      } catch (EOFException e) { }
    } catch (IOException e) { }
    return classFile;
  }

  private final char minor_version;
  private final char major_version;

  private final CFConstantPool constantPool;

  private char constant_value_index;
  private char synthetic_index;
  private char deprecated_index;
  private char code_index;
  private char exceptions_index;
  private char inner_classes_index;
  private char source_file_index;
  private char lines_index;
  private char locals_index;

  private char access_flags;
  private final char this_class;
  private final char super_class;
  private final char[] interfaces;

  private final CFFieldInfo[] fields;
  private final CFMethodInfo[] methods;

  private CFInnerInfo[] inner_classes;
  private char source_file;
  private boolean synthetic;
  private boolean deprecated;

  /**
   * Creates a <CODE>ClassFile</CODE> object reading its contents from a
   * <CODE>DataInputStream</CODE>. The existance of extra bytes past the
   * end of the binary class image is ignored and should be treated
   * accordingly by the caller. Also the caller should catch
   * <CODE>EOFException</CODE> when dealing with a possibly truncated
   * image.
   *
   * @param in the <CODE>DataInputStream</CODE> to be read from.
   * @exception ClassFormatException if the binary class image
   *            is malformed or has any superficial inconsistency.
   * @exception UnsupportedClassVersionException if the class
   *            version is not supported by this implementation.
   * @exception EOFException if the end of the stream is reached when
   *            reading the binary class image.
   * @exception IOException if an exception occurs in the underlying
   *            stream.
   */
  public ClassFile(DataInputStream in) throws ClassFormatException, IOException {
    int magic = in.readInt();
    if (magic != MAGIC)
      throw new ClassFormatException("Bad magic number");

    minor_version = in.readChar();
    major_version = in.readChar();
    if (major_version < LOWER_MAJOR_VERSION || (major_version == LOWER_MAJOR_VERSION && minor_version < LOWER_MINOR_VERSION) ||
        major_version > UPPER_MAJOR_VERSION || (major_version == UPPER_MAJOR_VERSION && minor_version > UPPER_MINOR_VERSION))
      throw new UnsupportedClassVersionException("Unsupported major.minor version "+(int)major_version+"."+(int)minor_version);

    constantPool = new CFConstantPool(in);

    access_flags = in.readChar();
    if ((access_flags & ACC_INTERFACE) != 0)
      access_flags |= ACC_ABSTRACT;

    this_class = in.readChar();
    if (constantPool.tag(this_class) != CONSTANT_CLASS)
      throw new ClassFormatException("Illegal constant pool index");
    String this_name = constantPool.getClass(this_class);

    if (this_name.charAt(0) != '[') {
      if ((access_flags & (ACC_FINAL|ACC_ABSTRACT)) == (ACC_FINAL|ACC_ABSTRACT))
        throw new ClassFormatException("Illegal class modifiers: 0x"+Integer.toHexString(access_flags));
    } else {
      if ((access_flags & (ACC_FINAL|ACC_ABSTRACT|ACC_INTERFACE)) != (ACC_FINAL|ACC_ABSTRACT))
        throw new ClassFormatException("Illegal class modifiers: 0x"+Integer.toHexString(access_flags));
      if ((access_flags & ACC_PUBLIC) == 0 && this_name.charAt(this_name.lastIndexOf('[')+1) != 'L')
        throw new ClassFormatException("Illegal class modifiers: 0x"+Integer.toHexString(access_flags));
    }

    super_class = in.readChar();
    if (super_class == 0) {
      if (!this_name.equals("java/lang/Object"))
        throw new ClassFormatException("Bad superclass index");
    } else if (constantPool.tag(super_class) != CONSTANT_CLASS)
      throw new ClassFormatException("Bad superclass index");

    char interfaces_count = in.readChar();
    interfaces = new char[interfaces_count];
    for (int i = 0; i < interfaces_count; i++) {
      char iface_index = in.readChar();
      if (constantPool.tag(iface_index) != CONSTANT_CLASS)
        throw new ClassFormatException("Interface name has bad constant pool index");
      String iface_name = constantPool.getClass(iface_index);
      for (int j = 0; j < i; j++)
        if (iface_name.equals(constantPool.getClass(interfaces[j])))
          throw new ClassFormatException("Repeative interface name");
      interfaces[i] = iface_index;
    }

    char fields_count = in.readChar();
    fields = new CFFieldInfo[fields_count];
    for (int i = 0; i < fields_count; i++) {
      CFFieldInfo field = new CFFieldInfo(in);
      for (int j = 0; j < i; j++)
        if (field.getName().equals(fields[j].getName()) && field.getDescriptor().equals(fields[j].getDescriptor()))
          throw new ClassFormatException("Repeative field name/signature");
      fields[i] = field;
    }

    char methods_count = in.readChar();
    methods = new CFMethodInfo[methods_count];
    for (int i = 0; i < methods_count; i++) {
      CFMethodInfo method = new CFMethodInfo(in);
      for (int j = 0; j < i; j++)
        if (method.getName().equals(methods[j].getName()) && method.getDescriptor().equals(methods[j].getDescriptor()))
          throw new ClassFormatException("Repeative method name/signature");
      methods[i] = method;
    }

    char attributes_count = in.readChar();
    for (int j = 0; j < attributes_count; j++) {
      char name_index = in.readChar();
      if (constantPool.tag(name_index) != CONSTANT_UTF8)
        throw new ClassFormatException("Illegal constant pool index");
      String attr_name = constantPool.getUTF8(name_index);
      int attr_length = in.readInt();
      if (attr_name.equals("SourceFile")) {
        source_file_index = name_index;
        if (source_file != 0)
          throw new ClassFormatException("Multiple SourceFile attributes");
        if (attr_length != 2)
          throw new ClassFormatException("SourceFile attribute has wrong length");
        source_file = in.readChar();
        if (constantPool.tag(source_file) != CONSTANT_UTF8)
          throw new ClassFormatException("Illegal constant pool index");
      } else if (attr_name.equals("InnerClasses")) {
        inner_classes_index = name_index;
        if (inner_classes != null)
          throw new ClassFormatException("Multiple InnerClasses attributes");
        char inners_count = in.readChar();
        if (attr_length != 2+8*inners_count)
          throw new ClassFormatException("InnerClasses attribute has wrong length");
        inner_classes = new CFInnerInfo[inners_count];
        for (int k = 0; k < inners_count; k++)
          inner_classes[k] = new CFInnerInfo(in);
      } else if (attr_name.equals("Synthetic")) {
        synthetic_index = name_index;
        if (attr_length != 0)
          throw new ClassFormatException("Synthetic attribute has wrong length");
        synthetic = true;
      } else if (attr_name.equals("Deprecated")) {
        deprecated_index = name_index;
        if (attr_length != 0)
          throw new ClassFormatException("Deprecated attribute has wrong length");
        deprecated = true;
      } else {
        skip(in, attr_length);
      }
    }
  }

  /**
   * Retrieves the minor version number of the current <CODE>ClassFile</CODE>.
   *
   * @return the minor version number as read from file.
   */
  public int getMinorVersion() {
    return minor_version;
  }

  /**
   * Retrieves the major version number of the current <CODE>ClassFile</CODE>.
   *
   * @return the major version number as read from file.
   */
  public int getMajorVersion() {
    return major_version;
  }

  /**
   * Retrieves the constant pool of the current <CODE>ClassInfo</CODE>.
   *
   * @return a <CODE>ConstantPool</CODE> object.
   */
  public ConstantPool getConstantPool() {
    return constantPool;
  }

  /**
   * Checks if the current <CODE>ClassFile</CODE> is public.
   *
   * @return <CODE>true</CODE> if it is public, <CODE>false</CODE>
   *         otherwise.
   */
  public boolean isPublic() {
    return (access_flags & ACC_PUBLIC) != 0;
  }

  /**
   * Checks if the current <CODE>ClassFile</CODE> is package private.
   *
   * @return <CODE>true</CODE> if it is package private, <CODE>false</CODE>
   *         otherwise.
   */
  public boolean isPackagePrivate() {
    return (access_flags & ACC_PUBLIC) == 0;
  }

  /**
   * Checks if the current <CODE>ClassFile</CODE> is final.
   *
   * @return <CODE>true</CODE> if it is final, <CODE>false</CODE>
   *         otherwise.
   */
  public boolean isFinal() {
    return (access_flags & ACC_FINAL) != 0;
  }

  /**
   * Checks if the current <CODE>ClassFile</CODE> has its super
   * flag set.
   *
   * @return <CODE>true</CODE> if the super flag is set, <CODE>false</CODE>
   *         otherwise.
   */
  public boolean isSuper() {
    return (access_flags & ACC_SUPER) != 0;
  }

  /**
   * Checks if the current <CODE>ClassFile</CODE> is actually an
   * interface rather than a class.
   *
   * @return <CODE>true</CODE> if it is an interface, <CODE>false</CODE>
   *         otherwise.
   */
  public boolean isInterface() {
    return (access_flags & ACC_INTERFACE) != 0;
  }

  /**
   * Checks if the current <CODE>ClassFile</CODE> is abstract.
   *
   * @return <CODE>true</CODE> if it is abstract, <CODE>false</CODE>
   *         otherwise.
   */
  public boolean isAbstract() {
    return (access_flags & ACC_ABSTRACT) != 0;
  }

  /**
   * Retrieves the access flags present in the current
   * <CODE>ClassFile</CODE>.
   *
   * @return the access flags packed in an integer.
   */
  public int getAccessFlags() {
    return access_flags;
  }

  /**
   * Retrieves the class name for the current <CODE>ClassFile</CODE>.
   *
   * @return a <CODE>String</CODE> object representing the class name.
   */
  public String getName() {
    return constantPool.getClass(this_class);
  }

  /**
   * Retrieves the class name for the superclass of the current <CODE>ClassFile</CODE>.
   *
   * @return a <CODE>String</CODE> object representing the superclass name, or
   *         null if the class has no superclass.
   */
  public String getSuperclass() {
    return super_class == 0 ? null : constantPool.getClass(super_class);
  }

  /**
   * Retrieves the number of interfaces implemented by the
   * current <CODE>ClassInfo</CODE>.
   *
   * @return an <CODE>integer</CODE> value.
   */
  public int getInterfaceCount() {
    return interfaces.length;
  }

  /**
   * Retrieves the class name for an interface implemented by the
   * current <CODE>ClassInfo</CODE>.
   *
   * @param index the interface index in the interface array.
   * @return an <CODE>String</CODE> object.
   * @exception IndexOutOfBoundsException if the index is out of bounds.
   */
  public String getInterface(int index) {
    return constantPool.getClass(interfaces[index]);
  }

  /**
   * Retrieves the classes names for the interfaces implemented by the
   * current <CODE>ClassFile</CODE>.
   *
   * @return an array of <CODE>String</CODE> objects.
   */
  public String[] getInterfaces() {
    String[] array = new String[interfaces.length];
    for (int i = 0; i < array.length; i++)
      array[i] = constantPool.getClass(interfaces[i]);
    return array;
  }

  /**
   * Retrieves the number of fields present in the current
   * <CODE>ClassInfo</CODE>.
   *
   * @return an <CODE>integer</CODE> value.
   */
  public int getFieldCount() {
    return fields.length;
  }

  /**
   * Retrieves a field present in the current <CODE>ClassFile</CODE>.
   *
   * @param name the field name.
   * @param descriptor the field descriptor.
   * @return a <CODE>FieldInfo</CODE> object or null if no such field exits.
   */
  public FieldInfo getField(String name, String descriptor) {
    for (int i = 0; i < fields.length; i++) {
      CFFieldInfo field = fields[i];
      if (name.equals(field.getName()) && descriptor.equals(field.getDescriptor()))
        return field;
    }
    return null;
  }

  /**
   * Retrieves a field present in the current <CODE>ClassInfo</CODE>.
   *
   * @param index the field index in the field array.
   * @return a <CODE>FieldInfo</CODE> object.
   * @exception IndexOutOfBoundsException if the index is out of bounds.
   */
  public FieldInfo getField(int index) {
    return fields[index];
  }

  /**
   * Retrieves all fields present in the current <CODE>ClassFile</CODE>.
   *
   * @return an array of <CODE>FieldInfo</CODE> objects.
   */
  public FieldInfo[] getFields() {
    return (CFFieldInfo[])fields.clone();
  }

  /**
   * Retrieves the number of methods present in the current
   * <CODE>ClassInfo</CODE>.
   *
   * @return an <CODE>integer</CODE> value.
   */
  public int getMethodCount() {
    return methods.length;
  }

  /**
   * Retrieves a method present in the current <CODE>ClassFile</CODE>.
   *
   * @param name the method name.
   * @param descriptor the method descriptor.
   * @return a <CODE>MethodInfo</CODE> object or null if no such method exits.
   */
  public MethodInfo getMethod(String name, String descriptor) {
    for (int i = 0; i < methods.length; i++) {
      CFMethodInfo method = methods[i];
      if (name.equals(method.getName()) && descriptor.equals(method.getDescriptor()))
        return method;
    }
    return null;
  }

  /**
   * Retrieves a method present in the current <CODE>ClassInfo</CODE>.
   *
   * @param index the method index in the method array.
   * @return a <CODE>MethodInfo</CODE> object.
   * @exception IndexOutOfBoundsException if the index is out of bounds.
   */
  public MethodInfo getMethod(int index) {
    return methods[index];
  }

  /**
   * Retrieves all methods present in the current <CODE>ClassFile</CODE>.
   *
   * @return an array of <CODE>MethodInfo</CODE> objects.
   */
  public MethodInfo[] getMethods() {
    return (CFMethodInfo[])methods.clone();
  }

  /**
   * Retrieves the number of inner classes present in the current
   * <CODE>ClassInfo</CODE>.
   *
   * @return an <CODE>integer</CODE> value.
   */
  public int getInnerClassCount() {
    return inner_classes == null ? 0 : inner_classes.length;
  }

  /**
   * Retrieves a inner class present in the current <CODE>ClassInfo</CODE>.
   *
   * @param index the inner class index in the inner class array.
   * @return a <CODE>InnerInfo</CODE> object, or null if not available.
   * @exception IndexOutOfBoundsException if the index is out of bounds.
   */
  public InnerInfo getInnerClass(int index) {
    return inner_classes == null ? null : inner_classes[index];
  }

  /**
   * Retrieves all inner classes present in the current <CODE>ClassFile</CODE>.
   *
   * @return an array of <CODE>InnerInfo</CODE> objects.
   */
  public InnerInfo[] getInnerClasses() {
    return inner_classes == null ? null : (CFInnerInfo[])inner_classes.clone();
  }

  /**
   * Retrieves the source file name in which the current
   * <CODE>ClassFile</CODE> was declared. Actually, the
   * contents of a <I>SourceFile</I> attribute if available.
   *
   * @return a <CODE>String</CODE> object representing the file
   *         name, of <CODE>null</CODE> if this information is
   *         not available.
   */
  public String getSourceFile() {
    return source_file == 0 ? null : constantPool.getUTF8(source_file);
  }

  /**
   * Checks if the current <CODE>ClassFile</CODE> is synthetic,
   * i.e.it has a <I>Synthetic</I> attribute.
   *
   * @return <CODE>true</CODE> if it is synthetic, <CODE>false</CODE>
   *         otherwise.
   */
  public boolean isSynthetic() {
    return synthetic;
  }

  /**
   * Checks if the current <CODE>ClassFile</CODE> has been
   * deprecated, i.e.it has a <I>Deprecated</I> attribute.
   *
   * @return <CODE>true</CODE> if it is deprecated, <CODE>false</CODE>
   *         otherwise.
   */
  public boolean isDeprecated() {
    return deprecated;
  }

  /**
   * This method writes the contents of this <CODE>ClassFile</CODE>
   * to a <CODE>DataOutputStream</CODE> object.
   *
   * @param out the <CODE>DataOutputStream</CODE> to be written to.
   * @exception IOException if an exception occurs in the underlying
   *            stream.
   */
  public void writeTo(DataOutputStream out) throws IOException {
    out.writeInt(MAGIC);
    out.writeChar(minor_version);
    out.writeChar(major_version);
    constantPool.writeTo(out);
    out.writeChar(access_flags);
    out.writeChar(this_class);
    out.writeChar(super_class);
    out.writeChar(interfaces.length);
    for (int i = 0; i < interfaces.length; i++)
      out.writeChar(interfaces[i]);
    out.writeChar(fields.length);
    for (int i = 0; i < fields.length; i++)
      fields[i].writeTo(out);
    out.writeChar(methods.length);
    for (int i = 0; i < methods.length; i++)
      methods[i].writeTo(out);
    out.writeChar(
      (inner_classes != null ? 1 : 0) +
      (source_file != 0 ? 1 : 0) +
      (synthetic ? 1 : 0) +
      (deprecated ? 1 : 0)
    );
    if (inner_classes != null) {
      out.writeChar(inner_classes_index);
      out.writeInt(2+8*inner_classes.length);
      out.writeChar(inner_classes.length);
      for (int i = 0; i < inner_classes.length; i++)
        inner_classes[i].writeTo(out);
    }
    if (source_file != 0) {
      out.writeChar(source_file_index);
      out.writeInt(2);
      out.writeChar(source_file);
    }
    if (synthetic) {
      out.writeChar(synthetic_index);
      out.writeInt(0);
    }
    if (deprecated) {
      out.writeChar(deprecated_index);
      out.writeInt(0);
    }
  }

  private static abstract class cp_info {
    final byte tag;
    cp_info(byte tag) { this.tag = tag; }
  }

  private static final class cp_ref1 extends cp_info {
    char index;
    cp_ref1(byte tag) { super(tag); }
  }

  private static final class cp_ref2 extends cp_info {
    char index0;
    char index1;
    cp_ref2(byte tag) { super(tag); }
  }

  private static final class cp_dat4 extends cp_info {
    int bytes;
    cp_dat4(byte tag) { super(tag); }
  }

  private static final class cp_dat8 extends cp_info {
    long bytes;
    cp_dat8(byte tag) { super(tag); }
  }

  private static final class cp_utf8 extends cp_info {
    String bytes;
    cp_utf8() { super(CONSTANT_UTF8); }
  }

  private final class CFConstantPool implements ConstantPool {

    private final cp_info[] entries;

    CFConstantPool(DataInputStream in) throws ClassFormatException, IOException {
      char cp_size = in.readChar();
      if (cp_size == 0)
        throw new ClassFormatException("Illegal constant pool size");
      entries = new cp_info[cp_size];
      for (int i = 1; i < entries.length; i++) {
        byte tag = in.readByte();
        switch (tag) {
        case CONSTANT_CLASS:
        case CONSTANT_STRING:
          cp_ref1 ref1_entry = new cp_ref1(tag);
          ref1_entry.index = in.readChar();
          entries[i] = ref1_entry;
          break;
        case CONSTANT_FIELDREF:
        case CONSTANT_METHODREF:
        case CONSTANT_INTERFACEMETHODREF:
        case CONSTANT_NAMEANDTYPE:
          cp_ref2 ref2_entry = new cp_ref2(tag);
          ref2_entry.index0 = in.readChar();
          ref2_entry.index1 = in.readChar();
          entries[i] = ref2_entry;
          break;
        case CONSTANT_INTEGER:
        case CONSTANT_FLOAT:
          cp_dat4 dat4_entry = new cp_dat4(tag);
          dat4_entry.bytes = in.readInt();
          entries[i] = dat4_entry;
          break;
        case CONSTANT_LONG:
        case CONSTANT_DOUBLE:
          if (i+1 == entries.length)
            throw new ClassFormatException("Illegal constant pool type");
          cp_dat8 dat8_entry = new cp_dat8(tag);
          dat8_entry.bytes = in.readLong();
          entries[i] = dat8_entry;
          i++;
          break;
        case CONSTANT_UTF8:
          cp_utf8 utf8_entry = new cp_utf8();
          try {
            utf8_entry.bytes = in.readUTF();
          } catch (UTFDataFormatException e) {
            throw new ClassFormatException("Illegal UTF8 string in constant pool");
          }
          entries[i] = utf8_entry;
          break;
        default:
          throw new ClassFormatException("Illegal constant pool type");
        }
      }

      for (int i = 1; i < entries.length; i++) {
        cp_info entry = entries[i];
        char index;
        switch (entry.tag) {
        case CONSTANT_LONG:
        case CONSTANT_DOUBLE:
          i++;
          break;
        case CONSTANT_CLASS:
          index = ((cp_ref1)entry).index;
          if (index >= entries.length || entries[index] == null || entries[index].tag != CONSTANT_UTF8)
            throw new ClassFormatException("Bad index in constant pool #"+i);
          String class_name = ((cp_utf8)entries[index]).bytes;
          if (!Syntax.isClassName(class_name))
            throw new ClassFormatException("Illegal Class name \""+class_name+"\"");
          break;
        case CONSTANT_STRING:
          index = ((cp_ref1)entry).index;
          if (index >= entries.length || entries[index] == null || entries[index].tag != CONSTANT_UTF8)
            throw new ClassFormatException("Bad index in constant pool #"+i);
          break;
        case CONSTANT_NAMEANDTYPE:
          cp_ref2 ref2_entry = (cp_ref2)entry;
          index = ref2_entry.index0;
          if (index >= entries.length || entries[index] == null || entries[index].tag != CONSTANT_UTF8)
            throw new ClassFormatException("Bad index in constant pool #"+i);
          index = ref2_entry.index1;
          if (index >= entries.length || entries[index] == null || entries[index].tag != CONSTANT_UTF8)
            throw new ClassFormatException("Bad index in constant pool #"+i);
          break;
        }
      }

      for (int i = 1; i < entries.length; i++) {
        cp_info entry = entries[i];
        switch (entry.tag) {
        case CONSTANT_LONG:
        case CONSTANT_DOUBLE:
          i++;
          break;
        case CONSTANT_FIELDREF:
        case CONSTANT_METHODREF:
        case CONSTANT_INTERFACEMETHODREF:
          cp_ref2 ref2_entry = (cp_ref2)entry;
          char index = ref2_entry.index0;
          if (index >= entries.length || entries[index] == null || entries[index].tag != CONSTANT_CLASS)
            throw new ClassFormatException("Bad index in constant pool #"+i);
          index = ref2_entry.index1;
          if (index >= entries.length || entries[index] == null || entries[index].tag != CONSTANT_NAMEANDTYPE)
            throw new ClassFormatException("Bad index in constant pool #"+i);
          ref2_entry = (cp_ref2)entries[index];
          String name = ((cp_utf8)entries[ref2_entry.index0]).bytes;
          if (!(entry.tag == CONSTANT_METHODREF && name.equals("<init>")) && !Syntax.isIdentifier(name))
            throw new ClassFormatException("Illegal Field name \""+name+"\"");
          String descriptor = ((cp_utf8)entries[ref2_entry.index1]).bytes;
          if (entry.tag == CONSTANT_FIELDREF) {
            if (!Syntax.isFieldDescriptor(descriptor))
              throw new ClassFormatException("Field \""+name+"\" has illegal signature \""+descriptor+"\"");
          } else {
            if (!Syntax.isMethodDescriptor(descriptor))
              throw new ClassFormatException("Method \""+name+"\" has illegal signature \""+descriptor+"\"");
            if (name.equals("<init>") && !Syntax.getReturnType(descriptor).equals("V"))
              throw new ClassFormatException("Method \""+name+"\" has illegal signature \""+descriptor+"\"");
          }
          break;
        }
      }
    }

    public ClassInfo getOwner() {
      return ClassFile.this;
    }

    public int size() {
      return entries.length;
    }

    public byte tag(int index) {
      return index < 1 || index >= entries.length || entries[index] == null ? 0 : entries[index].tag;
    }

    public String getUTF8(int index) {
      return ((cp_utf8)entries[index]).bytes;
    }

    public int getInteger(int index) {
      return ((cp_dat4)entries[index]).bytes;
    }

    public float getFloat(int index) {
      return Float.intBitsToFloat(getInteger(index));
    }

    public long getLong(int index) {
      return ((cp_dat8)entries[index]).bytes;
    }

    public double getDouble(int index) {
      return Double.longBitsToDouble(getLong(index));
    }

    public String getString(int index) {
      return getUTF8(((cp_ref1)entries[index]).index);
    }

    public String getClass(int index) {
      if (entries[index].tag != CONSTANT_CLASS)
        index = ((cp_ref2)entries[index]).index0;
      return getUTF8(((cp_ref1)entries[index]).index);
    }

    public String getName(int index) {
      if (entries[index].tag != CONSTANT_NAMEANDTYPE)
        index = ((cp_ref2)entries[index]).index1;
      return getUTF8(((cp_ref2)entries[index]).index0);
    }

    public String getDescriptor(int index) {
      if (entries[index].tag != CONSTANT_NAMEANDTYPE)
        index = ((cp_ref2)entries[index]).index1;
      return getUTF8(((cp_ref2)entries[index]).index1);
    }

    void writeTo(DataOutputStream out) throws IOException {
      out.writeChar(entries.length);
      for (int i = 1; i < entries.length; i++) {
        cp_info entry = entries[i];
        out.writeByte(entry.tag);
        switch (entry.tag) {
        case CONSTANT_CLASS:
        case CONSTANT_STRING:
          cp_ref1 ref1_entry = (cp_ref1)entry;
          out.writeChar(ref1_entry.index);
          break;
        case CONSTANT_FIELDREF:
        case CONSTANT_METHODREF:
        case CONSTANT_INTERFACEMETHODREF:
        case CONSTANT_NAMEANDTYPE:
          cp_ref2 ref2_entry = (cp_ref2)entry;
          out.writeChar(ref2_entry.index0);
          out.writeChar(ref2_entry.index1);
          break;
        case CONSTANT_INTEGER:
        case CONSTANT_FLOAT:
          cp_dat4 dat4_entry = (cp_dat4)entry;
          out.writeInt(dat4_entry.bytes);
          break;
        case CONSTANT_LONG:
        case CONSTANT_DOUBLE:
          cp_dat8 dat8_entry = (cp_dat8)entry;
          out.writeLong(dat8_entry.bytes);
          i++;
          break;
        case CONSTANT_UTF8:
          cp_utf8 utf8_entry = (cp_utf8)entry;
          out.writeUTF(utf8_entry.bytes);
          break;
        }
      }
    }

  }

  private final class CFFieldInfo implements FieldInfo {

    private final char access_flags;
    private final char name_index;
    private final char desc_index;
    private char constant_value;
    private boolean synthetic;
    private boolean deprecated;

    CFFieldInfo(DataInputStream in) throws ClassFormatException, IOException {

      access_flags = in.readChar();
      if ((access_flags & (ACC_PUBLIC|ACC_PRIVATE)) == (ACC_PUBLIC|ACC_PRIVATE))
        throw new ClassFormatException("Illegal field modifiers: 0x"+Integer.toHexString(access_flags));
      if ((access_flags & (ACC_PUBLIC|ACC_PROTECTED)) == (ACC_PUBLIC|ACC_PROTECTED))
        throw new ClassFormatException("Illegal field modifiers: 0x"+Integer.toHexString(access_flags));
      if ((access_flags & (ACC_PROTECTED|ACC_PRIVATE)) == (ACC_PROTECTED|ACC_PRIVATE))
        throw new ClassFormatException("Illegal field modifiers: 0x"+Integer.toHexString(access_flags));
      if ((access_flags & (ACC_FINAL|ACC_VOLATILE)) == (ACC_FINAL|ACC_VOLATILE))
        throw new ClassFormatException("Illegal field modifiers: 0x"+Integer.toHexString(access_flags));
      if (isInterface() && (access_flags & (ACC_PUBLIC|ACC_STATIC|ACC_FINAL|ACC_TRANSIENT)) != (ACC_PUBLIC|ACC_STATIC|ACC_FINAL))
        throw new ClassFormatException("Illegal field modifiers: 0x"+Integer.toHexString(access_flags));

      name_index = in.readChar();
      if (constantPool.tag(name_index) != CONSTANT_UTF8)
        throw new ClassFormatException("Illegal constant pool index");
      String field_name = constantPool.getUTF8(name_index);
      if (!Syntax.isIdentifier(field_name))
        throw new ClassFormatException("Illegal Field name \""+field_name+"\"");

      desc_index = in.readChar();
      if (constantPool.tag(desc_index) != CONSTANT_UTF8)
        throw new ClassFormatException("Illegal constant pool index");
      String field_desc = constantPool.getUTF8(desc_index);
      if (!Syntax.isFieldDescriptor(field_desc))
        throw new ClassFormatException("Field \""+field_name+"\" has illegal signature \""+field_desc+"\"");

      char attributes_count = in.readChar();
      for (int j = 0; j < attributes_count; j++) {
        char name_index = in.readChar();
        if (constantPool.tag(name_index) != CONSTANT_UTF8)
          throw new ClassFormatException("Illegal constant pool index");
        String attr_name = constantPool.getUTF8(name_index);
        int attr_length = in.readInt(); 
        if (attr_name.equals("ConstantValue")) {
          constant_value_index = name_index;
          if (constant_value != 0)
            throw new ClassFormatException("Multiple ConstantValue attributes");
          if (attr_length != 2)
            throw new ClassFormatException("Wrong size for VALUE attribute");
          constant_value = in.readChar();
          switch (constantPool.tag(constant_value)) {
          case CONSTANT_INTEGER:
            if (!field_desc.equals("I") && !field_desc.equals("Z") && 
                !field_desc.equals("B") && !field_desc.equals("S") && !field_desc.equals("C"))
              throw new ClassFormatException("Bad index into constant pool");
            break;
          case CONSTANT_FLOAT:
            if (!field_desc.equals("F"))
              throw new ClassFormatException("Bad index into constant pool");
            break;
          case CONSTANT_LONG:
            if (!field_desc.equals("J"))
              throw new ClassFormatException("Bad index into constant pool");
            break;
          case CONSTANT_DOUBLE:
            if (!field_desc.equals("D"))
              throw new ClassFormatException("Bad index into constant pool");
            break;
          case CONSTANT_STRING:
            if (!field_desc.equals("Ljava/lang/String;"))
              throw new ClassFormatException("Bad index into constant pool");
            break;
          default:
            throw new ClassFormatException("Bad index into constant pool");
          }
        } else if (attr_name.equals("Synthetic")) {
          synthetic_index = name_index;
          if (attr_length != 0)
            throw new ClassFormatException("Synthetic attribute has wrong length");
          synthetic = true;
        } else if (attr_name.equals("Deprecated")) {
          deprecated_index = name_index;
          if (attr_length != 0)
            throw new ClassFormatException("Deprecated attribute has wrong length");
          deprecated = true;
        } else {
          skip(in, attr_length);
        }
      }

    }

    public ClassInfo getOwner() {
      return ClassFile.this;
    }

    public int getIndex() {
      for (int i = 0; i < fields.length; i++)
        if (fields[i] == this)
          return i;
      return -1;
    }

    public boolean isPublic() {
      return (access_flags & ACC_PUBLIC) != 0;
    }

    public boolean isPrivate() {
      return (access_flags & ACC_PRIVATE) != 0;
    }

    public boolean isProtected() {
      return (access_flags & ACC_PROTECTED) != 0;
    }

    public boolean isPackagePrivate() {
      return (access_flags & (ACC_PUBLIC|ACC_PRIVATE|ACC_PROTECTED)) == 0;
    }

    public boolean isStatic() {
      return (access_flags & ACC_STATIC) != 0;
    }

    public boolean isFinal() {
      return (access_flags & ACC_FINAL) != 0;
    }

    public boolean isVolatile() {
      return (access_flags & ACC_VOLATILE) != 0;
    }

    public boolean isTransient() {
      return (access_flags & ACC_TRANSIENT) != 0;
    }

    public int getAccessFlags() {
      return access_flags;
    }

    public String getName() {
      return constantPool.getUTF8(name_index);
    }

    public String getDescriptor() {
      return constantPool.getUTF8(desc_index);
    }

    public Object getConstantValue() {
      if (constant_value != 0) {
        switch (constantPool.tag(constant_value)) {
        case CONSTANT_INTEGER:
          return new Integer(constantPool.getInteger(constant_value));
        case CONSTANT_FLOAT:
          return new Float(constantPool.getFloat(constant_value));
        case CONSTANT_LONG:
          return new Long(constantPool.getLong(constant_value));
        case CONSTANT_DOUBLE:
          return new Double(constantPool.getDouble(constant_value));
        case CONSTANT_STRING:
          return constantPool.getString(constant_value);
        }
      }
      return null;
    }

    public boolean isSynthetic() {
      return synthetic;
    }

    public boolean isDeprecated() {
      return deprecated;
    }

    void writeTo(DataOutputStream out) throws IOException {
      out.writeChar(access_flags);
      out.writeChar(name_index);
      out.writeChar(desc_index);
      out.writeChar(
        (constant_value != 0 ? 1 : 0) +
        (synthetic ? 1 : 0) +
        (deprecated ? 1 : 0)
      );
      if (constant_value != 0) {
        out.writeChar(constant_value_index);
        out.writeInt(2);
        out.writeChar(constant_value);
      }
      if (synthetic) {
        out.writeChar(synthetic_index);
        out.writeInt(0);
      }
      if (deprecated) {
        out.writeChar(deprecated_index);
        out.writeInt(0);
      }
    }

  }

  private final class CFMethodInfo implements MethodInfo {

    private final char access_flags;
    private final char name_index;
    private final char desc_index;
    private CFCodeInfo code;
    private char[] exceptions;
    private boolean synthetic;
    private boolean deprecated;

    CFMethodInfo(DataInputStream in) throws ClassFormatException, IOException {

      access_flags = in.readChar();

      name_index = in.readChar();
      if (constantPool.tag(name_index) != CONSTANT_UTF8)
        throw new ClassFormatException("Illegal constant pool index");
      String method_name = constantPool.getUTF8(name_index);
      if (!method_name.equals("<init>") && !method_name.equals("<clinit>") && !Syntax.isIdentifier(method_name))
        throw new ClassFormatException("Illegal Method name \""+method_name+"\"");

      if (!method_name.equals("<clinit>")) {
        if ((access_flags & (ACC_PUBLIC|ACC_PRIVATE)) == (ACC_PUBLIC|ACC_PRIVATE))
          throw new ClassFormatException("Illegal method modifiers: 0x"+Integer.toHexString(access_flags));
        if ((access_flags & (ACC_PUBLIC|ACC_PROTECTED)) == (ACC_PUBLIC|ACC_PROTECTED))
          throw new ClassFormatException("Illegal method modifiers: 0x"+Integer.toHexString(access_flags));
        if ((access_flags & (ACC_PRIVATE|ACC_PROTECTED)) == (ACC_PRIVATE|ACC_PROTECTED))
          throw new ClassFormatException("Illegal method modifiers: 0x"+Integer.toHexString(access_flags));
        if ((access_flags & ACC_ABSTRACT) != 0 && 
            (access_flags & (ACC_PRIVATE|ACC_STATIC|ACC_FINAL|ACC_NATIVE|ACC_STRICT|ACC_SYNCHRONIZED)) != 0)
          throw new ClassFormatException("Illegal method modifiers: 0x"+Integer.toHexString(access_flags));
        if (isInterface() && (access_flags & (ACC_PUBLIC|ACC_ABSTRACT)) != (ACC_PUBLIC|ACC_ABSTRACT))
          throw new ClassFormatException("Illegal method modifiers: 0x"+Integer.toHexString(access_flags));
        if (method_name.equals("<init>") &&
            (access_flags & (ACC_STATIC|ACC_FINAL|ACC_SYNCHRONIZED|ACC_NATIVE|ACC_ABSTRACT)) != 0)
          throw new ClassFormatException("Illegal method modifiers: 0x"+Integer.toHexString(access_flags));
      }

      desc_index = in.readChar();
      if (constantPool.tag(desc_index) != CONSTANT_UTF8)
        throw new ClassFormatException("Illegal constant pool index");
      String method_desc = constantPool.getUTF8(desc_index);
      if (!Syntax.isMethodDescriptor(method_desc))
        throw new ClassFormatException("Method \""+method_name+"\" has illegal signature \""+method_desc+"\"");
      if (method_name.equals("<clinit>")) {
        if (!method_desc.equals("()V"))
          throw new ClassFormatException("Method \""+method_name+"\" has illegal signature \""+method_desc+"\"");
      } else {
        if (method_name.equals("<init>") && !method_desc.endsWith("V"))
          throw new ClassFormatException("Method \""+method_name+"\" has illegal signature \""+method_desc+"\"");
        if (Syntax.getParametersSize(method_desc, (access_flags & ACC_STATIC) == 0) > 255)
          throw new ClassFormatException("Method \""+method_name+"\" has illegal signature \""+method_desc+"\"");
      }

      char attributes_count = in.readChar();
      for (int j = 0; j < attributes_count; j++) {
        char name_index = in.readChar();
        if (constantPool.tag(name_index) != CONSTANT_UTF8)
          throw new ClassFormatException("Illegal constant pool index");
        String attr_name = constantPool.getUTF8(name_index);
        int attr_length = in.readInt();
        if (attr_name.equals("Code")) {
          code_index = name_index;
          if ((access_flags & (ACC_ABSTRACT|ACC_NATIVE)) != 0 && !method_name.equals("<clinit>"))
            throw new ClassFormatException("Code attribute in native or abstract methods");
          if (code != null)
            throw new ClassFormatException("Multiple Code attributes");
          code = new CFCodeInfo(in, attr_length);
        } else if (attr_name.equals("Exceptions")) {
          exceptions_index = name_index;
          if (exceptions != null)
            throw new ClassFormatException("Multiple Exceptions attributes");
          char exceptions_count = in.readChar();
          if (attr_length != 2+2*exceptions_count)
            throw new ClassFormatException("Exceptions attribute has wrong length");
          exceptions = new char[exceptions_count];
          for (int k = 0; k < exceptions_count; k++) {
            char exception_index = in.readChar();
            if (constantPool.tag(exception_index) != CONSTANT_CLASS)
              throw new ClassFormatException("Exception name has bad constant pool index");
            exceptions[k] = exception_index;
          }
        } else if (attr_name.equals("Synthetic")) {
          synthetic_index = name_index;
          if (attr_length != 0)
            throw new ClassFormatException("Synthetic attribute has wrong length");
          synthetic = true;
        } else if (attr_name.equals("Deprecated")) {
          deprecated_index = name_index;
          if (attr_length != 0)
            throw new ClassFormatException("Deprecated attribute has wrong length");
          deprecated = true;
        } else {
          skip(in, attr_length);
        }
      }
      if (code == null && ((access_flags & (ACC_ABSTRACT|ACC_NATIVE)) == 0 || method_name.equals("<clinit>")))
        throw new ClassFormatException("Missing code attribute");

    }

    public ClassInfo getOwner() {
      return ClassFile.this;
    }

    public int getIndex() {
      for (int i = 0; i < methods.length; i++)
        if (methods[i] == this)
          return i;
      return -1;
    }

    public boolean isPublic() {
      return (access_flags & ACC_PUBLIC) != 0;
    }

    public boolean isPrivate() {
      return (access_flags & ACC_PRIVATE) != 0;
    }

    public boolean isProtected() {
      return (access_flags & ACC_PROTECTED) != 0;
    }

    public boolean isPackagePrivate() {
      return (access_flags & (ACC_PUBLIC|ACC_PRIVATE|ACC_PROTECTED)) == 0;
    }

    public boolean isStatic() {
      return (access_flags & ACC_STATIC) != 0;
    }

    public boolean isFinal() {
      return (access_flags & ACC_FINAL) != 0;
    }

    public boolean isSynchronized() {
      return (access_flags & ACC_SYNCHRONIZED) != 0;
    }

    public boolean isNative() {
      return (access_flags & ACC_NATIVE) != 0;
    }

    public boolean isAbstract() {
      return (access_flags & ACC_ABSTRACT) != 0;
    }

    public boolean isStrict() {
      return (access_flags & ACC_STRICT) != 0;
    }

    public int getAccessFlags() {
      return access_flags;
    }

    public String getName() {
      return constantPool.getUTF8(name_index);
    }

    public String getDescriptor() {
      return constantPool.getUTF8(desc_index);
    }

    public CodeInfo getCode() {
      return code;
    }

    public int getExceptionCount() {
      return exceptions == null ? 0 : exceptions.length;
    }

    public String getException(int index) {
      return exceptions == null ? null : constantPool.getClass(exceptions[index]);
    }

    public String[] getExceptions() {
      if (exceptions == null)
        return null;
      else {
        String[] array = new String[exceptions.length];
        for (int i = 0; i < array.length; i++)
          array[i] = constantPool.getClass(exceptions[i]);
        return array;
      }
    }

    public boolean isSynthetic() {
      return synthetic;
    }

    public boolean isDeprecated() {
      return deprecated;
    }

    void writeTo(DataOutputStream out) throws IOException {
      out.writeChar(access_flags);
      out.writeChar(name_index);
      out.writeChar(desc_index);
      out.writeChar(
        (code != null ? 1 : 0) +
        (exceptions != null ? 1 : 0) +
        (synthetic ? 1 : 0) +
        (deprecated ? 1 : 0)
      );
      if (code != null)
        code.writeTo(out);
      if (exceptions != null) {
        out.writeChar(exceptions_index);
        out.writeInt(2+2*exceptions.length);
        out.writeChar(exceptions.length);
        for (int j = 0; j < exceptions.length; j++)
          out.writeChar(exceptions[j]);
      }
      if (synthetic) {
        out.writeChar(synthetic_index);
        out.writeInt(0);
      }
      if (deprecated) {
        out.writeChar(deprecated_index);
        out.writeInt(0);
      }
    }

    private final class CFCodeInfo implements CodeInfo {

      private final char max_stack;
      private final char max_locals;
      private final byte[] text;
      private final CFHandlerInfo[] handlers;
      private LineInfo[] lines;
      private LocalInfo[] locals;

      private transient boolean static_checked;
      private transient int[] text_info;

      CFCodeInfo(DataInputStream in, int attr_length) throws ClassFormatException, IOException {
        max_stack = in.readChar();
        max_locals = in.readChar();

        if (Syntax.getParametersSize(getDescriptor(), !isStatic() && !getName().equals("<clinit>")) > max_locals)
          throw new ClassFormatException("Arguments can't fit into locals");

        int text_length = in.readInt();
        if (text_length < 0 || text_length > 65535)
          throw new ClassFormatException("Code of a method longer than 65535 bytes");
        text = new byte[text_length];
        in.readFully(text);

        char handlers_count = in.readChar();
        handlers = new CFHandlerInfo[handlers_count];
        for (int k = 0; k < handlers_count; k++)
          handlers[k] = new CFHandlerInfo(in);
      
        long acc_size = 0;
        char mattrs_count = in.readChar();
        for (int k = 0; k < mattrs_count; k++) {
          char mname_index = in.readChar();
          if (constantPool.tag(mname_index) != CONSTANT_UTF8)
            throw new ClassFormatException("Illegal constant pool index");
          String mattr_name = constantPool.getUTF8(mname_index);
          int mattr_length = in.readInt();
          if (mattr_name.equals("LineNumberTable")) {
            lines_index = mname_index;
            char lines_count = in.readChar();
            if (mattr_length != 2+4*lines_count)
              throw new ClassFormatException("LineNumberTable attribute has wrong length");
            if (lines == null)
              lines = new LineInfo[lines_count];
            else {
              LineInfo[] tmp = lines;
              lines = new LineInfo[lines_count+tmp.length];
              System.arraycopy(tmp, 0, lines, lines_count, tmp.length);
            }
            for (int l = 0; l < lines_count; l++) {
              LineInfo line = new LineInfo();
              line.start_pc = in.readChar();
              line.line_number = in.readChar();
              if (line.start_pc >= text.length)
                throw new ClassFormatException("Invalid pc in line number table");
              lines[l] = line;
            }
          } else if (mattr_name.equals("LocalVariableTable")) {
            locals_index = mname_index;
            char locals_count = in.readChar();
            if (mattr_length != 2+10*locals_count)
              throw new ClassFormatException("LocalVariableTable attribute has wrong length");
            if (locals == null)
              locals = new LocalInfo[locals_count];
            else {
              LocalInfo[] tmp = locals;
              locals = new LocalInfo[locals_count+tmp.length];
              System.arraycopy(tmp, 0, locals, locals_count, tmp.length);
            }
            for (int l = 0; l < locals_count; l++) {
              LocalInfo local = new LocalInfo();
              local.start_pc = in.readChar();
              local.length = in.readChar();
              if (local.start_pc >= text.length || local.start_pc+local.length > text.length)
                throw new ClassFormatException("Invalid start_pc/length in local var table");
              local.name_index = in.readChar();
              if (constantPool.tag(local.name_index) != CONSTANT_UTF8)
                throw new ClassFormatException("Illegal constant pool index");
              String local_name = constantPool.getUTF8(local.name_index);
              if (!Syntax.isIdentifier(local_name))
                throw new ClassFormatException("Illegal LocalVariable name \""+local_name+"\"");
              local.desc_index = in.readChar();
              if (constantPool.tag(local.desc_index) != CONSTANT_UTF8)
                throw new ClassFormatException("Illegal constant pool index");
              String local_desc = constantPool.getUTF8(local.desc_index);
              if (!Syntax.isFieldDescriptor(local_desc))
                throw new ClassFormatException("LocalVariable \""+local_name+"\" has illegal signature \""+local_desc+"\"");
              local.index = in.readChar();
              locals[l] = local;
            }
          } else {
            skip(in, mattr_length);
          }
          acc_size += ((long)mattr_length) & 0x00000000FFFFFFFFL;
        }
        if ((((long)attr_length) & 0x00000000FFFFFFFFL) != (2+2+4+text.length+2+8*handlers.length+2+6*mattrs_count)+acc_size)
          throw new ClassFormatException("Code attribute has wrong length");

        if (lines != null)
          Arrays.sort(lines, new Comparator() {
            public int compare(Object one, Object another) {
              return ((LineInfo)one).start_pc-((LineInfo)another).start_pc;
            }
          });

      }

      public MethodInfo getOwner() {
        return CFMethodInfo.this;
      }

      public int getMaxStack() {
        return max_stack;
      }

      public int getMaxLocals() {
        return max_locals;
      }

      public byte[] getText() {
        return (byte[])text.clone();
      }

      public int[] getTextInfo() {
        return text_info == null ? null : (int[])text_info.clone();
      }

      public int getHandlerCount() {
        return handlers.length;
      }

      public HandlerInfo getHandler(int index) {
        return handlers[index];
      }

      public HandlerInfo[] getHandlers() {
        return (CFHandlerInfo[])handlers.clone();
      }

      public int lineOf(int pc) {
        if (lines == null)
          return -1;
        int left = 0;
        int right = lines.length;
        while (left < right) {
          int middle = (left+right)/2;
          LineInfo line = lines[middle];
          if (pc < line.start_pc)
            right = middle;
          else if (line.start_pc < pc)
            left = middle+1;
          else
            return line.line_number;
        }
        return left == 0 ? -1 : lines[left-1].line_number;
      }

      public String getLocalName(int pc, int index) {
        if (locals == null)
          return null;
        for (int i = 0; i < locals.length; i++) {
          LocalInfo local = locals[i];
          if (local.start_pc <= pc && pc <= local.start_pc+local.length)
            if (local.index == index)
              return constantPool.getUTF8(local.name_index);
        }
        return null;
      }

      public String getLocalDescriptor(int pc, int index) {
        if (locals == null)
          return null;
        for (int i = 0; i < locals.length; i++) {
          LocalInfo local = locals[i];
          if (local.start_pc <= pc && pc <= local.start_pc+local.length)
            if (local.index == index)
              return constantPool.getUTF8(local.desc_index);
        }
        return null;
      }

      public void checkStaticConstraints() throws VerifyException {
        if (!static_checked) {
          text_info = new int[text.length];
          Bytecode.checkStaticConstraints(this, text, text_info, handlers);
          static_checked = true;
        }
      }

      public void checkStructuralConstraints(Namespace nameSpace) throws VerifyException {
        checkStaticConstraints();
        BytecodeVerifier.checkStructuralConstraints(nameSpace, this, text, text_info, handlers);
      }

      void writeTo(DataOutputStream out) throws IOException {
        out.writeChar(code_index);
        out.writeInt(
          2+2+4+text.length+2+8*handlers.length+2 +
          (lines != null ? 2+4+2+4*lines.length : 0) +
          (locals != null ? 2+4+2+10*locals.length : 0)
        );
        out.writeChar(max_stack);
        out.writeChar(max_locals);
        out.writeInt(text.length);
        out.write(text);
        out.writeChar(handlers.length);
        for (int i = 0; i < handlers.length; i++)
          handlers[i].writeTo(out);
        out.writeChar(
          (lines != null ? 1 : 0) +
          (locals != null ? 1 : 0)
        );
        if (lines != null) {
          out.writeChar(lines_index);
          out.writeInt(2+4*lines.length);
          out.writeChar(lines.length);
          for (int i = 0; i < lines.length; i++) {
            LineInfo line = lines[i];
            out.writeChar(line.start_pc);
            out.writeChar(line.line_number);
          }
        }
        if (locals != null) {
          out.writeChar(locals_index);
          out.writeInt(2+10*locals.length);
          out.writeChar(locals.length);
          for (int i = 0; i < locals.length; i++) {
            LocalInfo local = locals[i];
            out.writeChar(local.start_pc);
            out.writeChar(local.length);
            out.writeChar(local.name_index);
            out.writeChar(local.desc_index);
            out.writeChar(local.index);
          }
        }
      }

      private final class CFHandlerInfo implements HandlerInfo {

        private final char start_pc;
        private final char end_pc;
        private final char handler_pc;
        private final char catch_type;

        CFHandlerInfo(DataInputStream in) throws ClassFormatException, IOException {
          start_pc = in.readChar();
          if (start_pc >= text.length)
            throw new ClassFormatException("Invalid exception handler start PC");
          end_pc = in.readChar();
          if (end_pc > text.length)
            throw new ClassFormatException("Invalid exception handler end PC");
          if (start_pc >= end_pc)
            throw new ClassFormatException("Invalid exception handler window");
          handler_pc = in.readChar();
          if (handler_pc >= text.length)
            throw new ClassFormatException("Invalid exception handler PC");
          catch_type = in.readChar();
          if (catch_type != 0)
            if (constantPool.tag(catch_type) != CONSTANT_CLASS)
              throw new ClassFormatException("Illegal constant pool index");
        }

        public CodeInfo getOwner() {
          return CFCodeInfo.this;
        }

        public int getIndex() {
          for (int i = 0; i < handlers.length; i++)
            if (handlers[i] == this)
              return i;
          return -1;
        }

        public int getStartPC() {
          return start_pc;
        }

        public int getEndPC() {
          return end_pc;
        }

        public int getHandlerPC() {
          return handler_pc;
        }

        public String getCatchType() {
          return catch_type == 0 ? null : constantPool.getClass(catch_type);
        }

        public boolean encloses(int pc) {
          return start_pc <= pc && pc < end_pc;
        }

        void writeTo(DataOutputStream out) throws IOException {
          out.writeChar(start_pc);
          out.writeChar(end_pc);
          out.writeChar(handler_pc);
          out.writeChar(catch_type);
        }

      }

    }

  }

  private static final class LineInfo {
    char start_pc;
    char line_number;
  }

  private static final class LocalInfo {
    char start_pc;
    char length;
    char name_index;
    char desc_index;
    char index;
  }

  private final class CFInnerInfo implements InnerInfo {

    private final char inner_index;
    private final char outer_index;
    private final char name_index;
    private char access_flags;

    CFInnerInfo(DataInputStream in) throws ClassFormatException, IOException {
      inner_index = in.readChar();
      if (constantPool.tag(inner_index) != CONSTANT_CLASS)
        throw new ClassFormatException("Illegal constant pool index");
      outer_index = in.readChar();
      if (outer_index != 0)
        if (constantPool.tag(outer_index) != CONSTANT_CLASS)
          throw new ClassFormatException("Illegal constant pool index");
      name_index = in.readChar();
      if (name_index != 0)
        if (constantPool.tag(name_index) != CONSTANT_UTF8)
          throw new ClassFormatException("Illegal constant pool index");
      access_flags = in.readChar();
      if ((access_flags & ACC_INTERFACE) != 0)
        access_flags |= ACC_ABSTRACT;
      if ((access_flags & (ACC_PUBLIC|ACC_PRIVATE)) == (ACC_PUBLIC|ACC_PRIVATE))
        throw new ClassFormatException("Illegal class modifiers: 0x"+Integer.toHexString(access_flags));
      if ((access_flags & (ACC_PUBLIC|ACC_PROTECTED)) == (ACC_PUBLIC|ACC_PROTECTED))
        throw new ClassFormatException("Illegal class modifiers: 0x"+Integer.toHexString(access_flags));
      if ((access_flags & (ACC_PRIVATE|ACC_PROTECTED)) == (ACC_PRIVATE|ACC_PROTECTED))
        throw new ClassFormatException("Illegal class modifiers: 0x"+Integer.toHexString(access_flags));
      if ((access_flags & (ACC_FINAL|ACC_ABSTRACT)) == (ACC_FINAL|ACC_ABSTRACT))
        throw new ClassFormatException("Illegal class modifiers: 0x"+Integer.toHexString(access_flags));
    }

    public ClassInfo getOwner() {
      return ClassFile.this;
    }

    public int getIndex() {
      for (int i = 0; i < inner_classes.length; i++)
        if (inner_classes[i] == this)
          return i;
      return -1;
    }

    public String getInnerClass() {
      return constantPool.getClass(inner_index);
    }

    public String getOuterClass() {
      return outer_index == 0 ? null : constantPool.getClass(outer_index);
    }

    public String getName() {
      return name_index == 0 ? null : constantPool.getUTF8(name_index);
    }

    public boolean isPublic() {
      return (access_flags & ACC_PUBLIC) != 0;
    }

    public boolean isPrivate() {
      return (access_flags & ACC_PRIVATE) != 0;
    }

    public boolean isProtected() {
      return (access_flags & ACC_PROTECTED) != 0;
    }

    public boolean isPackagePrivate() {
      return (access_flags & (ACC_PUBLIC|ACC_PRIVATE|ACC_PROTECTED)) == 0;
    }

    public boolean isStatic() {
      return (access_flags & ACC_STATIC) != 0;
    }

    public boolean isFinal() {
      return (access_flags & ACC_FINAL) != 0;
    }

    public boolean isInterface() {
      return (access_flags & ACC_INTERFACE) != 0;
    }

    public boolean isAbstract() {
      return (access_flags & ACC_ABSTRACT) != 0;
    }

    public int getAccessFlags() {
      return access_flags;
    }

    void writeTo(DataOutputStream out) throws IOException {
      out.writeChar(inner_index);
      out.writeChar(outer_index);
      out.writeChar(name_index);
      out.writeChar(access_flags);
    }

  }

  private static void skip(DataInputStream in, int size) throws IOException {
    long count = 0;
    long total = (long)size & 0xFFFFFFFFL;
    while (count < total) {
      long read = in.skip(total-count);
      if (read == -1)
        throw new EOFException();
      count += read;
    }
  }

}

